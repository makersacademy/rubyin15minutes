# Chapter 1

## Installing Ruby

You'll be happy to know that Ruby comes preinstalled on all Mac's. Open the terminal on your machine and then type in

```
ruby -v
```

It will return something like `ruby 2.1.5p273` or similar. Ideally you want to have something over version 2.0.0 (the general system version) to be on the safer side. If you have a Windows machine, throw it in the bin and buy a Mac. You'll thank us later. On a serious note, if you want to use Windows, there are a few guides available on how to install Ruby on Windows.

Now go back to the terminal and type

```
`irb`
```

This launches an interactive Ruby shell and will let you code along with this tutorial. Note any time you see code written in this tutorial it will:

```
look like this
```

# Method Calls

In Ruby, what most languages call a ‘function’ is actually referred to as a ‘method’. There are a couple of ways to call a method in Ruby.

```
puts("Hello World!")
```

Here you’re calling the method puts, passing the String “Hello, world!” as the argument, inside parentheses.

Parentheses are often optional/implicit in Ruby, so you could just as well type:

```
puts "Hello World!"
```


It’s also possible to pass multiple arguments to some methods. In these cases, each argument is separated by a comma:

```
puts("Hello World!", "I am coding.")
```

Although we often won’t need parentheses, in some cases they’re necessary. Rather than worrying about when to use them, let’s stick to using parentheses so we won’t be tripped up by these special cases.


# Variables

An ordinary, regular variable is known as a *local variable*. They are created through assignment using the *=* sign.

```
number = 21
```

You can have multiple words used and the general convention in Ruby is to use *snake case* like so:

```
my_lucky_number = 13
```

Slightly more readable right?

# Truth and Falsehood

In Ruby, everything is considered to be true, unless it's *false* or *nil*. That might seem a little strange at times, and possibly a little confusing but it's really important to remember.

For example, 0 is true, as is String = "Zero". An empty string can be true as can an empty array.

All numbers are true, all strings are true, well everything is true apart from *false* and *nil*.

This will make more sense as we go through the tutorial but for the time being, just remember it.

# Strings, Objects and Methods

*Strings* are simply a sequence of text that are written in quotation marks. You can use both single and double quotation marks in Ruby so both of the following work:

```
my_name = 'Jordan'
my_friends_name = "Ruben"
```

You can use any charachter in a string, as long as it's between the quotation marks:

```
my_age = "I'm 30 years old :-)"
```

You may also have heard in Ruby, that everything is an object. Strings are objects in Ruby and this means they get their very own set of methods. That means you can do fun things like:

```
"makers academy".upcase
```

Try it and see what it does.

In the example, the object is everything before the full stop. So `"makers academy"` is the object. The method we are calling is `upcase`. This is the method that will capitalise the object on which it is being called.

You can get a list of methods available for any object by using `irb`. Try

```
"my name".methods
```

and see what it returns. There's a lot to go through, have a little play around in `irb` to see what some of them do. For an exhaustive list of all the current methods available you can visit [Ruby Docs](https://www.ruby-doc.org)

Just like with functions in other languages, Ruby methods can have arguments:

```
"learn to code".include?("code")
```

will return `true` if the `String` object "learn to code" includes the string "code" which we have _passed_ as an _argument_ to the `include?` method.

```
Challenge : Is the `include?` method case sensitive? Try it in ``irb`` to find out
```

# Method Chaining

Method chaining is a handy technique that allows you to sequentially invoke multiple methods in one expression. It helps to improve the readability of the code while reducing the amount of code you actually need to write. We chain methods using the `dot notation`.

In method chaining, the interpreter will pass along the chain of commands from left to right, passing the output from one method to the input of the next, eliminating the need for intermediate variables.

Using Method Chaining :

```
string_backwards_in_caps = "makers academy".upcase.reverse
```

Using intermediate variables :

```
string = "makers academy"

upper_case = string.upcase

string_backwards_in_caps = upper_case.reverse
```
The above two expressions will have the same outputs.

In both cases, the string "makers academy" is turned into all capitals using the `upcase` method. The letters are then reveresed using the `reverse` method. The new `String` in capitals and reversed is set to the `variable` called `string_backwards_in_caps`.

Here is slightly more complicated & different version :

```
"makers academy".upcase.reverse.next.swapcase
```

Try this in ``irb`` and see what happens to the string.

# Conditionals

Conditionals are super simple in Ruby. They’re structured as follows:

```
if some_condition
	puts “this code will be executed if some_condition is true”
else
	puts “this code will be executed if some_condition is false”
end
```
You’ll need to put the if, else and end keywords on separate lines as shown above. Technically you don’t have to indent the code, but you definitely should. It’s the expected convention (and Ruby loves convention!). Not to mention the fact that it makes the code much easier to read later.

But what about if you want more than one condition? You can use the keyword `elsif`, and you can do something like this :

```
if some_condition
	puts “this code will be executed if some_condition is true”
elsif another_condition
	puts “this code will be executed if another_condition is true”
elsif a_third_condition
	puts “this code will be executed if a_third_condition is true"
else
	puts “this code will be executed if none of the above are true”
end
```
use it as many times as you want to try out.

# Defining Methods

The anatomy of a method is as follows :

```
def method_name(argument_1, argument_2)
 #your method code goes here
end
```

A method always starts with the keyword `def` and finishes with the keyword `end`.

After the `def` goes the method name. This can be anything you like (try to make it relevant to what the method does). Ruby has a list of [reserved words](www.zenspider.com/Languages/Ruby/QuickRef.html#reserved-words) that you **can't** use.

You should try to give your methods clear, descriptive names. Ideally the method should read like a regular English sentence and, if pushed, someone should be able to pretty much guess what the method should do just by the name of the method and the name(s) of the argument(s) that can be passed to it.

If your method takes any arguments, they go in parentheses after the method_name, and are separated with commas.

Some methods take no arguments:

```
def say_happy_birthday
	puts "Happy Birthday!!"
end
```
While others take one argument:

```
￼def say_happy_birthday_to(name)
     puts “Happy Birthday #{name}”
end
```

And some can take two (or more) arguments:

```
￼def say_happy_birthday_to(name, repetitions)
     repetitions.times { |i| puts “Happy Birthday #{name}”}
end
```

Try this in `irb` and can you figure out a method that will let you say happy birthday to someone 3 times?

```
say_happy_birthday_to(“Jordan”, 3)
```

In Ruby, by default, methods will return the last executed statement in the definition. So:

```
￼def yearly_salary(monthly_salary)
     monthly_salary * 12
end
```

Will both return the value of monthly_salary multiplied by 12. You can assign the output of a method to a variable too, so:

```
jordans_wishful_yearly_salary = yearly_salary(100,000)
```

Will set the variable jordans_wishful_yearly_salary to the integer 1,200,00, since we defined the method yearly_salary(100,000) to return 100,000 * 12, which is 1,200,000.

Before you look at the solution on the next page, why don’t you try to write a method that will check whether the number given to it as argument is positive or negative, and display a message with the answer? Try to write it in `irb` now.

```
SOLUTION:

def positive_or_negative(number)
     if number > 0
          puts “Number is positive”
     else
          puts “Number is negative”
     end
end
```

You can test if your method is working by entering:

```
positive_or_negative(-7)
```

Which should now display Number is negative.

```
CHALLENGE:


Could you try to extend the make_positive method to accommodate the case of 0, which is neither positive nor negative? Tweet @MakersAcademy if you want help, or send us your solution when you’ve worked it out!

```

 
